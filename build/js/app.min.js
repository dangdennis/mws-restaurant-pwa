/**
 * Common database helper functions.
 */
class DBHelper {
    constructor() {
        this.IDB = new IDB();
    }

    /**
     * Database URL.
     * Returns an object of all endpoints
     */
    get DATABASE_URL() {
        const domain = `http://localhost:`;
        const port = 1337; // Change this to your server port
        const origin = `${domain}${port}`;
        return {
            restaurants: `${origin}/restaurants/`, // GET: All restaurants, or 1 with ID
            restaurantsFavorites: `${origin}/restaurants/?is_favorite=true`, // GET: All favorited restaurants
            restaurantReviews: `${origin}/reviews/?restaurant_id=`, // GET: All reviews by restaurant ID
            reviews: `${origin}/reviews/`, // GET: All reviews, or 1 with ID
            faveRestaurant: id => `${origin}/restaurants/${id}/?is_favorite=true`, // PUT: Favorite a restaurant by ID
            unfaveRestaurant: id => `${origin}/restaurants/${id}/?is_favorite=false`, // PUT: Unfavorite a restaurant by ID
            editReview: id => `${origin}/reviews/${id}` // PUT = update, DELETE = delete review
        };
    }

    /**
     * General fetch utility
     * @param {String} url
     * @param {String} method
     */
    async apiFetcher(url, method = 'GET') {
        try {
            const options = {
                method
            };
            const result = await fetch(url, options).then(res => res.json());
            return result;
        } catch (error) {
            console.warn('You got a network error:', error);
            return error;
        }
    }

    /**
     * Fetches all favorite restaurants only
     * @param {function} callback
     */
    async fetchFavoriteRestaurants(callback) {
        const url = this.DATABASE_URL.restaurantsFavorites;
        const res = await this.apiFetcher(url);
        if (callback) {
            callback(res);
        }
    }

    /**
     * A user can favorite a restaurant
     * @param {String} id
     * @param {Boolean} faveState
     * @param {Function} callback
     */
    async faveRestaurant(id, faveState, callback) {
        let url;
        if (!faveState) {
            url = this.DATABASE_URL.faveRestaurant(id);
        } else {
            url = this.DATABASE_URL.unfaveRestaurant(id);
        }
        const res = await this.apiFetcher(url, 'PUT');
        if (res.message === 'Failed to fetch') {
            let toast = VanillaToasts.create({
                title: 'Out of network!',
                text: 'Try favoriting later',
                type: 'error',
                timeout: 6000
            });
        } else {
            console.log('resssss', res);
            callback(res);
        }
    }

    /**
     * Fetches all restaurants
     */
    async fetchRestaurants() {
        let restaurants;

        try {
            // To invalidate old cache, if first time page load, pull restaurants via network
            const isInitialLoad = this.checkInitialLoadState();
            if (!isInitialLoad) {
                this.IDB.createObjectStore('restaurants');
                // Get restaurants from indexedDB if it exists
                restaurants = await this.IDB.get('restaurants', 'restaurants').then(res => res);
                if (restaurants) {
                    console.log('got restaurants from idb', restaurants);
                    return restaurants;
                }
            }

            // Fetch restaurants if still undefined after Idb attempt
            if (!restaurants) {
                const url = this.DATABASE_URL.restaurants;
                restaurants = await this.apiFetcher(url);
                this.IDB.set('restaurants', restaurants, 'restaurants');
                console.log('fetching restaurants from network');
                return restaurants;
            }
        } catch (error) {
            console.log('Request failed: ', error);
            return [];
        }
    }

    /**
     * Fetch a restaurant by its ID.
     */
    async fetchRestaurantById(id, callback) {
        let restaurant;
        const objStoreName = `restaurant`;
        try {
            const idbPromise = await this.IDB.createObjectStore(objStoreName);

            restaurant = await this.IDB.get(id, objStoreName).then(res => res);
            if (restaurant) {
                console.log('fetch restaurant from idb');
                if (callback) {
                    callback(null, restaurant);
                }
                return restaurant;
            }

            if (!restaurant) {
                const url = this.DATABASE_URL.restaurants + id;
                restaurant = await this.apiFetcher(url);
                this.IDB.set(id, restaurant, objStoreName);
                console.log('fetch restaurant from network');
                if (callback) {
                    callback(null, restaurant);
                }
                return restaurant;
            }
        } catch (error) {
            console.log('Request failed: ', error);
            return {};
        }
    }

    /**
     * Fetch Restaurant reviews by ID
     */
    async fetchRestaurantReviewsById(id, callback) {
        const url = this.DATABASE_URL.restaurantReviews + id;
        const res = await this.apiFetcher(url);
        if (callback) {
            callback(null, res);
        }
    }

    /**
     * Fetch restaurants by a cuisine type with proper error handling.
     */
    fetchRestaurantByCuisine(cuisine, callback) {
        // Fetch all restaurants  with proper error handling
        this.fetchRestaurants((error, restaurants) => {
            if (error) {
                callback(error, null);
            } else {
                // Filter restaurants to have only given cuisine type
                const results = restaurants.filter(r => r.cuisine_type == cuisine);
                if (callback) {
                    callback(null, results);
                }
            }
        });
    }

    /**
     * Fetch restaurants by a neighborhood with proper error handling.
     */
    fetchRestaurantByNeighborhood(neighborhood, callback) {
        // Fetch all restaurants
        this.fetchRestaurants((error, restaurants) => {
            if (error) {
                callback(error, null);
            } else {
                // Filter restaurants to have only given neighborhood
                const results = restaurants.filter(r => r.neighborhood == neighborhood);
                if (callback) {
                    callback(null, results);
                }
            }
        });
    }

    /**
     * Fetch restaurants by a cuisine and a neighborhood with proper error handling.
     */
    async fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, restaurants) {
        // Fetch all restaurants
        if (!restaurants || !restaurants.length) {
            restaurants = await this.fetchRestaurants();
        }
        let results = restaurants;
        if (cuisine != 'all') {
            // filter by cuisine
            results = results.filter(r => r.cuisine_type == cuisine);
        }
        if (neighborhood != 'all') {
            // filter by neighborhood
            results = results.filter(r => r.neighborhood == neighborhood);
        }

        return results;
    }

    /**
     * Fetch all neighborhoods with proper error handling.
     */
    filterNeighborhoods(restaurants) {
        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood);
        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i);
        return uniqueNeighborhoods;
    }

    /**
     * Fetch all cuisines with proper error handling.
     */
    filterCuisines(restaurants) {
        // Get all cuisines from all restaurants
        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type);
        // Remove duplicates from cuisines
        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i);
        return uniqueCuisines;
    }

    /**
     * Restaurant page URL.
     */
    urlForRestaurant(restaurant) {
        return `./restaurant.html?id=${restaurant.id}`;
    }

    /**
     * Restaurant image URL.
     */
    imageUrlForRestaurant(restaurant) {
        return `/img/${restaurant.photograph}.jpg`;
    }

    /**
     * Map marker for a restaurant.
     */
    mapMarkerForRestaurant(restaurant, map) {
        const marker = new google.maps.Marker({
            position: restaurant.latlng,
            title: restaurant.name,
            url: this.urlForRestaurant(restaurant),
            map: map,
            animation: google.maps.Animation.DROP
        });
        return marker;
    }

    /**
     * Unused
     * @param {Function} callback
     */
    async fetchAllReviews(callback) {
        const url = this.DATABASE_URL.faveRestaurant;
        const res = await this.apiFetcher(url);
        if (callback) {
            callback(res);
        }
    }

    /**
     * Unused
     * @param {String} id
     * @param {Function} callback
     */
    async fetchAReview(id, callback) {
        const url = this.DATABASE_URL.faveRestaurant + id;
        const res = await this.apiFetcher(url);
        if (callback) {
            callback(res);
        }
    }

    checkInitialLoadState() {
        if ('sessionStorage' in window) {
            if (sessionStorage.getItem('initialLoad') === 'false') {
                return false;
            }
            sessionStorage.setItem('initialLoad', 'false');
            return true;
        }
    }

    alternateInitialLoadState() {
        if ('sessionStorage' in window) {
            const currentLoadState = sessionStorage.getItem('initialLoad');
            const nextState = currentLoadState === 'false' ? true : false;
            sessionStorage.setItem('initialLoad', nextState);
        }
    }
}

class IDB {
    static get DATABASE_NAME() {
        return 'mws-restaurant';
    }

    isIndexedDBSupported() {
        if (!('indexedDB' in window)) {
            console.log("This browser doesn't support IndexedDB");
            return false;
        }
        return true;
    }

    createObjectStore(storeName) {
        if (this.isIndexedDBSupported) {
            const idbPromise = idb.open(IDB.DATABASE_NAME, 1, upgradeDb => {
                if (!upgradeDb.objectStoreNames.contains('restaurants')) {
                    console.log('creating object store name: ', 'restaurants');
                    upgradeDb.createObjectStore('restaurants');
                }
                if (!upgradeDb.objectStoreNames.contains('restaurant')) {
                    console.log('creating object store name: ', 'restaurant');
                    upgradeDb.createObjectStore('restaurant');
                }
                if (!upgradeDb.objectStoreNames.contains('reviews')) {
                    console.log('creating object store name: ', 'reviews');
                    const reviewsOS = upgradeDb.createObjectStore('reviews', { autoIncrement: true });
                    reviewsOS.createIndex('id', 'name', { unique: false });
                }
            });
            return idbPromise;
        }
    }

    set(key, val, storeName) {
        const dbPromise = idb.open(IDB.DATABASE_NAME, 1, upgradeDB => {
            if (!upgradeDb.objectStoreNames.contains(storeName)) {
                upgradeDB.createObjectStore(storeName);
            }
        });
        dbPromise.then(db => {
            const tx = db.transaction(storeName, 'readwrite');
            tx.objectStore(storeName).put(val, key);
            return tx.complete;
        }).then(() => console.log('Successfully stored data'));
    }

    get(key, storeName) {
        const dbPromise = idb.open(IDB.DATABASE_NAME, 1, upgradeDB => {
            if (!upgradeDb.objectStoreNames.contains(storeName)) {
                upgradeDB.createObjectStore(storeName);
            }
        });
        return dbPromise.then(db => {
            const retrieved = db.transaction(storeName).objectStore(storeName).get(key);
            return retrieved;
        });
    }

    delete(key, storeName) {
        const dbPromise = idb.open(IDB.DATABASE_NAME, 1, upgradeDB => {
            if (!upgradeDb.objectStoreNames.contains(storeName)) {
                upgradeDB.createObjectStore(storeName);
            }
        });
        dbPromise.then(function (db) {
            var tx = db.transaction(storeName, 'readwrite');
            var store = tx.objectStore(storeName);
            store.delete(key);
            return tx.complete;
        }).then(function () {
            console.log('Item deleted');
        });
    }

    getAll(storeName) {
        const dbPromise = idb.open(IDB.DATABASE_NAME, 1, upgradeDB => {
            if (!upgradeDb.objectStoreNames.contains(storeName)) {
                upgradeDB.createObjectStore(storeName);
            }
        });
        return dbPromise.then(db => {
            const tx = db.transaction(storeName, 'readonly');
            const store = tx.objectStore(storeName);
            return store.getAll();
        }).then(function (items) {
            return items;
        });
    }

    cursor(callback, storeName) {
        const dbPromise = idb.open(IDB.DATABASE_NAME, 1, upgradeDB => {
            if (!upgradeDb.objectStoreNames.contains(storeName)) {
                upgradeDB.createObjectStore(storeName);
            }
        });
        dbPromise.then(function (db) {
            var tx = db.transaction(storeName, 'readonly');
            var store = tx.objectStore(storeName);
            return store.openCursor();
        }).then(async function mapCursors(cursor) {
            if (!cursor) {
                return;
            }
            if (callback) {
                await callback(cursor.value, cursor.key);
            }
            return cursor.continue().then(mapCursors);
        }).then(function () {
            console.log('Done checking for offline reviews');
        });
    }
}
class Form {
    constructor() {
        this.el = {};
        this.isInitialLoad = true;
        this.IDB = new IDB();
    }
    initElements() {
        this.el.submitButton = document.querySelector('.js-submit-review-btn');
        this.el.form = document.querySelector('#ReviewForm');
        this.el.restaurantInput = document.querySelector('#RestaurantId');
        this.el.nameInput = document.querySelector('#ReviewerName');
        this.el.commentInput = document.querySelector('#ReviewComments');
        this.el.ratingInput = document.querySelector('#ReviewRating');
        this.el.reviewList = document.querySelector('#reviews-list');
    }
    initHandlers() {
        this.el.submitButton.addEventListener('click', this.handleReviewSubmission.bind(this));
    }

    getReviewFromForm() {
        const body = {
            restaurant_id: this.el.restaurantInput.value,
            name: this.el.nameInput.value,
            rating: parseInt(this.el.ratingInput.value),
            comments: this.el.commentInput.value
        };
        return body;
    }

    fetchReviewsFromNetwork() {
        const id = getParameterByName('id');
        DB.fetchRestaurantReviewsById(id, (error, reviews) => {
            this.el.reviewList.innerHTML = '';
            fillReviewsHTML(reviews);
        });
    }

    handleReviewSubmission(e) {
        if (this.validateForm.call(this)) {
            const review = this.getReviewFromForm();
            this.postReview(review).then(this.onFormSubmissionSuccess.bind(this)).catch(this.onFormSubmissionError.bind(this));
        }
    }

    postReview(reviewData) {
        return fetch('http://localhost:1337/reviews/', {
            body: JSON.stringify(reviewData),
            mode: 'cors',
            method: 'POST',
            headers: {
                'Content-Type': 'application/json; charset=utf-8'
            }
        });
    }

    onFormSubmissionSuccess(res) {
        if (res.status === 201) {

            let toast = VanillaToasts.create({
                title: 'Review submitted!',
                text: 'Thanks for sharing your thoughts.',
                type: 'success',
                timeout: 6000
            });
            this.fetchReviewsFromNetwork();
            this.resetForm();
        }
    }

    onFormSubmissionError(error) {
        // Cuz I don't know how else to check for network errors
        if (error.message === 'Failed to fetch') {
            let toast = VanillaToasts.create({
                title: 'Out of network!',
                text: 'Thanks for the review! Once you have connection, your review will be sent.',
                type: 'error',
                timeout: 6000
            });
            const review = this.getReviewFromForm();
            this.saveReviewToIDB(review);
            this.resetForm();
        }
    }

    validateForm() {
        if (this.el.nameInput.value.length === 0) {
            this.el.nameInput.setAttribute('aria-invalid', true);
            this.el.nameInput.style.border = '1px solid red';
            return false;
        }
        const rating = parseInt(this.el.ratingInput.value);
        if (isNaN(rating) || rating < 0 || rating > 5) {
            this.el.ratingInput.setAttribute('aria-invalid', true);
            this.el.ratingInput.style.border = '1px solid red';
            return false;
        }
        if (this.el.commentInput.value.length === 0) {
            this.el.commentInput.setAttribute('aria-invalid', true);
            this.el.commentInput.style.border = '1px solid red';
            return false;
        }

        return true;
    }

    setRestaurantIdToForm() {
        var restaurantId = location.search[location.search.indexOf('id=') + 3];
        this.el.restaurantInput.value = restaurantId;
    }

    resetForm() {
        this.el.nameInput.value = '';
        this.el.nameInput.setAttribute('aria-invalid', false);
        this.el.nameInput.style.border = '';
        this.el.commentInput.value = '';
        this.el.commentInput.setAttribute('aria-invalid', false);
        this.el.commentInput.style.border = '';
        this.el.ratingInput.value = '';
        this.el.ratingInput.setAttribute('aria-invalid', false);
        this.el.ratingInput.style.border = '';
    }

    saveReviewToIDB(review) {
        const objStoreName = 'reviews';
        this.IDB.set(undefined, review, objStoreName);
    }

    async getReviewsFromIDB() {
        const objStoreName = 'reviews';
        const reviews = await this.IDB.getAll(objStoreName);
        return reviews;
    }

    submitReviewsFromIDB() {
        const objStoreName = 'reviews';
        this.IDB.cursor(postReviewWithinIDB, objStoreName);

        let postReview = this.postReview.bind(this);
        let idbDelete = this.IDB.delete.bind(this);
        let fetchReviewsFromNetwork = this.fetchReviewsFromNetwork.bind(this);

        function postReviewWithinIDB(review, key) {
            postReview(review).then(res => {
                if (res.status === 201) {
                    idbDelete(key, objStoreName);
                    fetchReviewsFromNetwork();
                }
            });
        }
    }

    init() {
        this.initElements();
        this.initHandlers();
        this.setRestaurantIdToForm();
        if (this.isInitialLoad) {
            this.isInitialLoad = false;
            this.submitReviewsFromIDB();
        }
    }
}
'use strict';

(function () {
    function toArray(arr) {
        return Array.prototype.slice.call(arr);
    }

    function promisifyRequest(request) {
        return new Promise(function (resolve, reject) {
            request.onsuccess = function () {
                resolve(request.result);
            };

            request.onerror = function () {
                reject(request.error);
            };
        });
    }

    function promisifyRequestCall(obj, method, args) {
        var request;
        var p = new Promise(function (resolve, reject) {
            request = obj[method].apply(obj, args);
            promisifyRequest(request).then(resolve, reject);
        });

        p.request = request;
        return p;
    }

    function promisifyCursorRequestCall(obj, method, args) {
        var p = promisifyRequestCall(obj, method, args);
        return p.then(function (value) {
            if (!value) return;
            return new Cursor(value, p.request);
        });
    }

    function proxyProperties(ProxyClass, targetProp, properties) {
        properties.forEach(function (prop) {
            Object.defineProperty(ProxyClass.prototype, prop, {
                get: function () {
                    return this[targetProp][prop];
                },
                set: function (val) {
                    this[targetProp][prop] = val;
                }
            });
        });
    }

    function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {
        properties.forEach(function (prop) {
            if (!(prop in Constructor.prototype)) return;
            ProxyClass.prototype[prop] = function () {
                return promisifyRequestCall(this[targetProp], prop, arguments);
            };
        });
    }

    function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
        properties.forEach(function (prop) {
            if (!(prop in Constructor.prototype)) return;
            ProxyClass.prototype[prop] = function () {
                return this[targetProp][prop].apply(this[targetProp], arguments);
            };
        });
    }

    function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {
        properties.forEach(function (prop) {
            if (!(prop in Constructor.prototype)) return;
            ProxyClass.prototype[prop] = function () {
                return promisifyCursorRequestCall(this[targetProp], prop, arguments);
            };
        });
    }

    function Index(index) {
        this._index = index;
    }

    proxyProperties(Index, '_index', ['name', 'keyPath', 'multiEntry', 'unique']);

    proxyRequestMethods(Index, '_index', IDBIndex, ['get', 'getKey', 'getAll', 'getAllKeys', 'count']);

    proxyCursorRequestMethods(Index, '_index', IDBIndex, ['openCursor', 'openKeyCursor']);

    function Cursor(cursor, request) {
        this._cursor = cursor;
        this._request = request;
    }

    proxyProperties(Cursor, '_cursor', ['direction', 'key', 'primaryKey', 'value']);

    proxyRequestMethods(Cursor, '_cursor', IDBCursor, ['update', 'delete']);

    // proxy 'next' methods
    ['advance', 'continue', 'continuePrimaryKey'].forEach(function (methodName) {
        if (!(methodName in IDBCursor.prototype)) return;
        Cursor.prototype[methodName] = function () {
            var cursor = this;
            var args = arguments;
            return Promise.resolve().then(function () {
                cursor._cursor[methodName].apply(cursor._cursor, args);
                return promisifyRequest(cursor._request).then(function (value) {
                    if (!value) return;
                    return new Cursor(value, cursor._request);
                });
            });
        };
    });

    function ObjectStore(store) {
        this._store = store;
    }

    ObjectStore.prototype.createIndex = function () {
        return new Index(this._store.createIndex.apply(this._store, arguments));
    };

    ObjectStore.prototype.index = function () {
        return new Index(this._store.index.apply(this._store, arguments));
    };

    proxyProperties(ObjectStore, '_store', ['name', 'keyPath', 'indexNames', 'autoIncrement']);

    proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, ['put', 'add', 'delete', 'clear', 'get', 'getAll', 'getKey', 'getAllKeys', 'count']);

    proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, ['openCursor', 'openKeyCursor']);

    proxyMethods(ObjectStore, '_store', IDBObjectStore, ['deleteIndex']);

    function Transaction(idbTransaction) {
        this._tx = idbTransaction;
        this.complete = new Promise(function (resolve, reject) {
            idbTransaction.oncomplete = function () {
                resolve();
            };
            idbTransaction.onerror = function () {
                reject(idbTransaction.error);
            };
            idbTransaction.onabort = function () {
                reject(idbTransaction.error);
            };
        });
    }

    Transaction.prototype.objectStore = function () {
        return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));
    };

    proxyProperties(Transaction, '_tx', ['objectStoreNames', 'mode']);

    proxyMethods(Transaction, '_tx', IDBTransaction, ['abort']);

    function UpgradeDB(db, oldVersion, transaction) {
        this._db = db;
        this.oldVersion = oldVersion;
        this.transaction = new Transaction(transaction);
    }

    UpgradeDB.prototype.createObjectStore = function () {
        return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));
    };

    proxyProperties(UpgradeDB, '_db', ['name', 'version', 'objectStoreNames']);

    proxyMethods(UpgradeDB, '_db', IDBDatabase, ['deleteObjectStore', 'close']);

    function DB(db) {
        this._db = db;
    }

    DB.prototype.transaction = function () {
        return new Transaction(this._db.transaction.apply(this._db, arguments));
    };

    proxyProperties(DB, '_db', ['name', 'version', 'objectStoreNames']);

    proxyMethods(DB, '_db', IDBDatabase, ['close']);

    // Add cursor iterators
    // TODO: remove this once browsers do the right thing with promises
    ['openCursor', 'openKeyCursor'].forEach(function (funcName) {
        [ObjectStore, Index].forEach(function (Constructor) {
            // Don't create iterateKeyCursor if openKeyCursor doesn't exist.
            if (!(funcName in Constructor.prototype)) return;

            Constructor.prototype[funcName.replace('open', 'iterate')] = function () {
                var args = toArray(arguments);
                var callback = args[args.length - 1];
                var nativeObject = this._store || this._index;
                var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));
                request.onsuccess = function () {
                    callback(request.result);
                };
            };
        });
    });

    // polyfill getAll
    [Index, ObjectStore].forEach(function (Constructor) {
        if (Constructor.prototype.getAll) return;
        Constructor.prototype.getAll = function (query, count) {
            var instance = this;
            var items = [];

            return new Promise(function (resolve) {
                instance.iterateCursor(query, function (cursor) {
                    if (!cursor) {
                        resolve(items);
                        return;
                    }
                    items.push(cursor.value);

                    if (count !== undefined && items.length == count) {
                        resolve(items);
                        return;
                    }
                    cursor.continue();
                });
            });
        };
    });

    var exp = {
        open: function (name, version, upgradeCallback) {
            var p = promisifyRequestCall(indexedDB, 'open', [name, version]);
            var request = p.request;

            if (request) {
                request.onupgradeneeded = function (event) {
                    if (upgradeCallback) {
                        upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));
                    }
                };
            }

            return p.then(function (db) {
                return new DB(db);
            });
        },
        delete: function (name) {
            return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);
        }
    };

    if (typeof module !== 'undefined') {
        module.exports = exp;
        module.exports.default = module.exports;
    } else {
        self.idb = exp;
    }
})();
let restaurants, neighborhoods, cuisines;
var map;
var markers = [];
let DB = new DBHelper();

/**
 * Fetch neighborhoods and cuisines as soon as the page is loaded.
 */
document.addEventListener('DOMContentLoaded', async event => {
    console.log('initializing page');
    const restaurants = await DB.fetchRestaurants();
    fillNeighborhoodsHTML(DB.filterNeighborhoods(restaurants));
    fillCuisinesHTML(DB.filterCuisines(restaurants));
    updateRestaurants(restaurants);
});

/**
 * Set neighborhoods HTML.
 */
fillNeighborhoodsHTML = (neighborhoods = self.neighborhoods) => {
    const select = document.getElementById('neighborhoods-select');
    neighborhoods.forEach(neighborhood => {
        const option = document.createElement('option');
        option.innerHTML = neighborhood;
        option.value = neighborhood;
        select.append(option);
    });
};

/**
 * Set cuisines HTML.
 */
fillCuisinesHTML = (cuisines = self.cuisines) => {
    const select = document.getElementById('cuisines-select');

    cuisines.forEach(cuisine => {
        const option = document.createElement('option');
        option.innerHTML = cuisine;
        option.value = cuisine;
        select.append(option);
    });
};

/**
 * Initialize Google map, called from HTML.
 */
window.initMap = () => {
    let loc = {
        lat: 40.722216,
        lng: -73.987501
    };
    self.map = new google.maps.Map(document.getElementById('map'), {
        zoom: 12,
        center: loc,
        scrollwheel: false
    });
};

/**
 * Update page and map for current restaurants.
 */
updateRestaurants = restaurants => {
    const cSelect = document.getElementById('cuisines-select');
    const nSelect = document.getElementById('neighborhoods-select');

    const cIndex = cSelect.selectedIndex;
    const nIndex = nSelect.selectedIndex;

    const cuisine = cSelect[cIndex].value;
    const neighborhood = nSelect[nIndex].value;

    DB.fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, restaurants).then(filtered => {
        resetRestaurants(filtered);
        fillRestaurantsHTML(filtered);
    });
};

/**
 * Clear current restaurants, their HTML and remove their map markers.
 */
resetRestaurants = restaurants => {
    // Remove all restaurants
    self.restaurants = [];
    const ul = document.getElementById('restaurants-list');
    ul.innerHTML = '';

    // Remove all map markers
    self.markers.forEach(m => m.setMap(null));
    self.markers = [];
    self.restaurants = restaurants;
};

/**
 * Create all restaurants HTML and add them to the webpage.
 */
fillRestaurantsHTML = (restaurants = self.restaurants) => {
    const ul = document.getElementById('restaurants-list');
    ul.innerHTML = '';
    restaurants.forEach(restaurant => {
        ul.append(createRestaurantHTML(restaurant));
    });
    addMarkersToMap();
};

/**
 * Create restaurant HTML.
 */
createRestaurantHTML = restaurant => {
    const li = document.createElement('li');
    li.setAttribute('aria-label', 'restaurant');
    li.setAttribute('data-restaurant-id', restaurant.id);
    let isFavorite = restaurant.is_favorite === 'true' ? true : false;
    li.setAttribute('data-favorite', isFavorite);

    const image = document.createElement('img');
    image.className = 'restaurant-img';
    image.src = DB.imageUrlForRestaurant(restaurant);
    image.alt = `Image of ${restaurant.name} Restaurant`;
    li.append(image);

    const name = document.createElement('h2');
    name.innerHTML = restaurant.name;
    li.append(name);

    const neighborhood = document.createElement('p');
    neighborhood.innerHTML = restaurant.neighborhood;
    li.append(neighborhood);

    const address = document.createElement('p');
    address.innerHTML = restaurant.address;
    li.append(address);

    const more = document.createElement('a');
    more.innerHTML = 'View Details';
    more.href = DB.urlForRestaurant(restaurant);
    li.append(more);

    const heart = document.createElement('i');
    heart.classList.add('fa-heart', 'fa-2x');

    // Stupid database is storing true values as String 'false' in db
    if (isFavorite === true) {
        heart.classList.add('fas');
    } else {
        heart.classList.add('far');
    }
    heart.addEventListener('click', handleFavoriteClick);

    li.append(heart);

    return li;
};

function handleFavoriteClick() {
    const id = this.parentNode.getAttribute('data-restaurant-id');
    let isFavorite = this.parentNode.getAttribute('data-favorite');
    isFavorite = isFavorite === 'true' ? true : false;
    DB.faveRestaurant(id, isFavorite, callback);
    DB.alternateInitialLoadState();

    function callback(res) {
        const favoriteState = res.is_favorite === 'true' ? true : false;
        let toast = VanillaToasts.create({
            title: favoriteState ? 'Favorited!' : 'Unfavorited!',
            text: favoriteState ? `You've favorited ${res.name}` : `You've unfavorited ${res.name}`,
            type: 'info',
            timeout: 1500
        });
        const restaurants = DB.fetchRestaurants().then(fillRestaurantsHTML);
    }
}

/**
 * Add markers for current restaurants to the map.
 */
addMarkersToMap = (restaurants = self.restaurants) => {
    restaurants.forEach(restaurant => {
        // Add marker to the map
        const marker = DB.mapMarkerForRestaurant(restaurant, self.map);
        google.maps.event.addListener(marker, 'click', () => {
            window.location.href = marker.url;
        });
        self.markers.push(marker);
    });
};
let map;
let DB = new DBHelper();
let form = new Form();

window.addEventListener('DOMContentLoaded', () => {
    form.init();
});

/**
 * Initialize Google map, called from HTML.
 */
window.initMap = () => {
    fetchRestaurantFromURL((error, restaurant) => {
        if (error) {
            // Got an error!
            console.error(error);
        } else {
            self.map = new google.maps.Map(document.getElementById('map'), {
                zoom: 16,
                center: restaurant.latlng,
                scrollwheel: false
            });
            fillBreadcrumb(restaurant);
            DB.mapMarkerForRestaurant(restaurant, self.map);
        }
    });
};

/**
 * Get current restaurant from page URL.
 */
fetchRestaurantFromURL = callback => {
    const id = getParameterByName('id');
    if (!id) {
        // no id found in URL
        error = 'No restaurant id in URL';
        callback(error, null);
    } else {
        DB.fetchRestaurantById(id, (error, restaurant) => {
            fillRestaurantHTML(restaurant);
            callback(null, restaurant);
        });
        DB.fetchRestaurantReviewsById(id, (error, reviews) => {
            fillReviewsHTML(reviews);
        });
    }
};

/**
 * Create restaurant HTML and add it to the webpage
 */
fillRestaurantHTML = (restaurant = self.restaurant) => {
    const name = document.getElementById('restaurant-name');
    name.innerHTML = restaurant.name;

    const address = document.getElementById('restaurant-address');
    address.innerHTML = restaurant.address;

    const image = document.getElementById('restaurant-img');
    image.className = 'restaurant-img';
    image.src = DB.imageUrlForRestaurant(restaurant);
    image.alt = `Image fo ${restaurant.name} Restaurant`;

    const cuisine = document.getElementById('restaurant-cuisine');
    cuisine.innerHTML = restaurant.cuisine_type;

    // fill operating hours
    if (restaurant.operating_hours) {
        fillRestaurantHoursHTML(restaurant.operating_hours);
    }
};

/**
 * Create restaurant operating hours HTML table and add it to the webpage.
 */
fillRestaurantHoursHTML = (operatingHours = self.restaurant.operating_hours) => {
    const hours = document.getElementById('restaurant-hours');
    for (let key in operatingHours) {
        const row = document.createElement('tr');

        const day = document.createElement('td');
        day.innerHTML = key;
        row.appendChild(day);

        const time = document.createElement('td');
        time.innerHTML = operatingHours[key];
        row.appendChild(time);

        hours.appendChild(row);
    }
};

/**
 * Create all reviews HTML and add them to the webpage.
 */
fillReviewsHTML = reviews => {
    const container = document.getElementById('reviews-container');

    if (!reviews) {
        const noReviews = document.createElement('p');
        noReviews.innerHTML = 'No reviews yet!';
        container.appendChild(noReviews);
        return;
    }
    const ul = document.getElementById('reviews-list');
    reviews.forEach(review => {
        ul.appendChild(createReviewHTML(review));
    });
    container.appendChild(ul);
};

/**
 * Create review HTML and add it to the webpage.
 */
createReviewHTML = review => {
    const header = document.createElement('div');
    header.classList.add('header');
    const li = document.createElement('li');
    li.setAttribute('aria-label', 'Review');
    li.setAttribute('data-review-id', review.id);

    const name = document.createElement('p');
    name.innerHTML = review.name;
    name.classList.add('name');
    header.appendChild(name);

    const date = document.createElement('p');
    if (review.updatedAt) {
        date.innerHTML = new Date(review.updatedAt).toLocaleDateString();
    } else {
        date.innerHTML = new Date(review.createdAt).toLocaleDateString();
    }
    date.classList.add('date');
    header.appendChild(date);

    const rating = document.createElement('p');
    rating.innerHTML = `Rating: ${review.rating}`;
    rating.classList.add('rating');

    const comments = document.createElement('p');
    comments.innerHTML = review.comments;
    li.appendChild(header);
    li.appendChild(rating);
    li.appendChild(comments);

    const deleteBtn = document.createElement('button');
    deleteBtn.classList.add('btn', 'btn-danger');
    deleteBtn.setAttribute('aria-label', 'Delete this review');
    deleteBtn.textContent = 'Delete';
    // TODO: should have event delegation later
    deleteBtn.addEventListener('click', function (e) {
        deleteReview(this.parentNode.getAttribute('data-review-id'));
    });

    li.appendChild(deleteBtn);

    return li;
};

/**
 * Add restaurant name to the breadcrumb navigation menu
 */
fillBreadcrumb = restaurant => {
    const breadcrumb = document.getElementById('breadcrumb');
    const li = document.createElement('li');
    li.innerHTML = restaurant.name;
    breadcrumb.appendChild(li);
};

/**
 * Get a parameter by name from page URL.
 */
getParameterByName = (name, url) => {
    if (!url) url = window.location.href;
    name = name.replace(/[\[\]]/g, '\\$&');
    const regex = new RegExp(`[?&]${name}(=([^&#]*)|&|#|$)`),
          results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, ' '));
};

deleteReview = id => {
    const url = 'http://localhost:1337/reviews/' + id;
    fetch(url, {
        method: 'DELETE'
    }).then(_ => {
        const NodeToDelete = document.querySelector(`[data-review-id='${id}']`);
        NodeToDelete.outerHTML = '';
        console.log('Delete successful');
    }).catch(error => {
        console.error('error', error);
        let toast = VanillaToasts.create({
            title: 'Out of network!',
            text: 'Still in development: deletion will be saved and updated in network',
            type: 'error',
            timeout: 6000
        });
    });
};
(function (root, factory) {
    try {
        // commonjs
        if (typeof exports === 'object') {
            module.exports = factory();
            // global
        } else {
            root.VanillaToasts = factory();
        }
    } catch (error) {
        console.log('Isomorphic compatibility is not supported at this time for VanillaToasts.');
    }
})(this, function () {
    // We need DOM to be ready
    if (document.readyState === 'complete') {
        init();
    } else {
        window.addEventListener('DOMContentLoaded', init);
    }

    // Create VanillaToasts object
    VanillaToasts = {
        // In case toast creation is attempted before dom has finished loading!
        create: function () {
            console.error(['DOM has not finished loading.', '\tInvoke create method when DOMs readyState is complete'].join('\n'));
        },
        //function to manually set timeout after create
        setTimeout: function () {
            console.error(['DOM has not finished loading.', '\tInvoke create method when DOMs readyState is complete'].join('\n'));
        },
        toasts: {} //store toasts to modify later
    };
    var autoincrement = 0;

    // Initialize library
    function init() {
        // Toast container
        var container = document.createElement('div');
        container.id = 'vanillatoasts-container';
        document.body.appendChild(container);

        // @Override
        // Replace create method when DOM has finished loading
        VanillaToasts.create = function (options) {
            var toast = document.createElement('div');
            toast.id = ++autoincrement;
            toast.id = 'toast-' + toast.id;
            toast.className = 'vanillatoasts-toast';
            toast.setAttribute('aria-label', `Form submission status`);

            // title
            if (options.title) {
                var h4 = document.createElement('h4');
                h4.className = 'vanillatoasts-title';
                h4.innerHTML = options.title;
                toast.appendChild(h4);
            }

            // text
            if (options.text) {
                var p = document.createElement('p');
                p.className = 'vanillatoasts-text';
                p.innerHTML = options.text;
                toast.appendChild(p);
            }

            // icon
            if (options.icon) {
                var img = document.createElement('img');
                img.src = options.icon;
                img.className = 'vanillatoasts-icon';
                toast.appendChild(img);
            }

            // click callback
            if (typeof options.callback === 'function') {
                toast.addEventListener('click', options.callback);
            }

            // toast api
            toast.hide = function () {
                toast.className += ' vanillatoasts-fadeOut';
                toast.addEventListener('animationend', removeToast, false);
            };

            // autohide
            if (options.timeout) {
                setTimeout(toast.hide, options.timeout);
            }

            if (options.type) {
                toast.className += ' vanillatoasts-' + options.type;

                switch (options.type) {
                    case 'success':
                    case 'info':
                        toast.setAttribute('aria-live', 'polite');
                        break;
                    case 'error':
                    case 'warning':
                        toast.setAttribute('aria-live', 'assertive');
                        break;
                }
            }

            toast.addEventListener('click', toast.hide);

            function removeToast() {
                document.getElementById('vanillatoasts-container').removeChild(toast);
                delete VanillaToasts.toasts[toast.id]; //remove toast from object
            }

            document.getElementById('vanillatoasts-container').appendChild(toast);

            //add toast to object so its easily gettable by its id
            VanillaToasts.toasts[toast.id] = toast;

            return toast;
        };

        /*
        custom function to manually initiate timeout of
        the toast.  Useful if toast is created as persistant
        because we don't want it to start to timeout until
        we tell it to
        */
        VanillaToasts.setTimeout = function (toastid, val) {
            if (VanillaToasts.toasts[toastid]) {
                setTimeout(VanillaToasts.toasts[toastid].hide, val);
            }
        };
    }

    return VanillaToasts;
});